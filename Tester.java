import java.util.*;

class Tester {
    public static int random = 79;
    public static List<List<String>> arr2D; 
    public static Map<String, Map<String,Integer>> weights;
    public static GraphGenerator<String> generator;

    public static void main(String[] args) {
         
        Scanner scan = new Scanner(System.in);
        print("press enter to progress the program whenever there is a pause (enter)");
        scan.nextLine();
        print("this code will test the pros and cons of A* and Dijkstra's for searching through a graph.");
        print("it will test the total amount of time each algorithm takes as well as the distance of the path generated by each.");
        scan.nextLine();
        print("I will run the test on square Grid graphs of different sizes.");
        print("I also experimented with grid graphs with randomly generated distances within the range 1-100 between nodes.");
        scan.nextLine();
        print("on unweighted graphs, in this program, A* can be run with the following heuristics:");
        print("Manhattan distance, euclidean distance");
        scan.nextLine();
        print("on weighted graphs, where relative position of nodes is known, I use a heuristic based on the euclidean distance, average path distance, and known neighbor's distance. Since the weights are random and unknown, I cannot create a heuristic that is both efficient and always finds the shortest path. \n The heuristic I came up with balances finding a relatively short path with traversing the graph efficiently.");
        print("INPUT VERIFICATION: the shortest path's distance can be verified by the ouput of dijkstra's algorithm for all tests.");
        print("start? (press enter)");
        scan.nextLine();
        print("enter 1 or 2 for Manhattan distance or Euclidean distance heuristic");
        int heuristic = scan.nextInt();
        String heur = "";
        if (heuristic == 1) {
            heur = "Manhattan";
        }
        if (heuristic == 2) {
            heur = "Euclidean";
        }
        scan.nextLine();
        int numNodes = 0;
        int edgeWeight = 1;
        for (int i = 0; i < 4; i++) {
            if (i == 0) {
                numNodes = 100;
                print("first: unweighted grid graphs");
                print("first graph size = " + numNodes + " nodes");
            } else if (i == 1) {
                numNodes = 10000;
                print("second graph size = " + numNodes + " nodes");
            } else if (i == 2) {
                numNodes = 1000000;
                print("third graph size = " + numNodes + " nodes");
            } else if (i == 3) {
                numNodes = 1960000;
                print("fourth graph size = " + numNodes + " nodes");
            }
            print("randomly generated start and end node: ");
            int range = (int) Math.sqrt(numNodes);
            int[] start = { randomInt(range), randomInt(range) };
            int[] end = { randomInt(range), randomInt(range) };
            print("start: " + arrToString(start));
            print("destination: " + arrToString(end));
            print("");
            List<String> nodes = genNodes(numNodes);
            generator = new GraphGenerator<>(nodes);
            generator.createGridGraph((int)Math.sqrt(numNodes),1);
            arr2D = generator.get2DArray(); 
            weights = generator.getGraph();
            testDijkstras(start, end, edgeWeight);
            print("");
            testAStar(start, end, heur, edgeWeight);
            print("(press enter)");
            scan.nextLine();
        }
        print("A* is much faster than dijkstra's since it only finds the path to the destination");
        print("Since I am using admissable heuristics, A* also always finds the shortest path");
        print("INPUT VERIFICATION: the shortest path's distance can be verified by the ouput of dijkstra's algorithm for all tests.");
        scan.nextLine();
        print("lets try the weighted grid graph where only relative position, average edgeweight, and edgeweight of immediate neighbors are known.");
        print("here I will use a made up heuristic that will likely overestimate the shortest path, but should still find a relatively short path and be fast on large graphs");
        scan.nextLine();
        numNodes = 0;
        edgeWeight = 2;
        heur = "Custom";
        for (int i = 0; i < 4; i++) {
            if (i == 0) {
                numNodes = 100;
                print("first: weighted grid graph");
                print("first graph size = " + numNodes + " nodes");
            } else if (i == 1) {
                numNodes = 10000;
                print("second graph size = " + numNodes + " nodes");
            } else if (i == 2) {
                numNodes = 1000000;
                print("third graph size = " + numNodes + " nodes");
            } else if (i == 3) {
                numNodes = 1960000;
                print("fourth graph size = " + numNodes + " nodes");
            }
            print("randomly generated start and end node: ");
            int range = (int) Math.sqrt(numNodes);
            int[] start = { randomInt(range), randomInt(range) };
            int[] end = { randomInt(range), randomInt(range) };
            print("start: " + arrToString(start));
            print("destination: " + arrToString(end));
            print("");
            List<String> nodes = genNodes(numNodes);
            generator = new GraphGenerator<>(nodes);
            generator.createGridGraph((int)Math.sqrt(numNodes),2);
            arr2D = generator.get2DArray(); 
            weights = generator.getGraph();
            testDijkstras(start, end, edgeWeight);
            print("");
            testAStar(start, end, heur, edgeWeight);
            print("(press enter)");
            scan.nextLine();
        }
        print("in conclusion, A* is more efficient as graph size increases, but without a correct heuristic it will not usually find the shortest path");
        print("in the testing, A* was much faster in both types of graphs, but in the second type the heuristic did not yield the shortest path.");
        print("dijkstra's always finds the shortest path, but it is a greedy algorithm that visits many unnecessary nodes");

        print("I also wanted to test bfs and dfs vs A* on the weighted graph, but I am running out of time to turn this in.");
        scan.close();
    }

    private static String arrToString(int[] arr) {
        return "row: " + arr[0] + " column: " + arr[1];
    }

    private static int randomInt(int range) {
        Random rand = new Random(random *= 2);
        return rand.nextInt(range);
    }

    private static List<String> genNodes(int numNodes) {
        List<String> listOfStrings = new ArrayList<>();
        int nodeInt = 1;
        String maxNode = "";
        for (int i = 0; i <= numNodes; i++) {
            maxNode = "" + (char) ('a' + i % 26) + nodeInt;
            listOfStrings.add(maxNode);
            if (i % 26 == 0) {
                nodeInt++;
            }
        }
        return listOfStrings;

    }

    private static void testDijkstras(int[] start, int[] end, int edgeWeight) {
        Map<String, Map<String, Integer>> weights = generator.getGraph();
        Dijkstras<String> dijkstras = new Dijkstras<>(arr2D, weights);
        Long startTime = System.nanoTime();
        Integer a = dijkstras.run(arr2D.get(start[0]).get(start[1]), arr2D.get(end[0]).get(end[1]));
        Long endTime = System.nanoTime();
        Long duration = endTime - startTime;
        print("Dijkstras algorithm: ");
        print("Duration: " + duration / 1_000_000 + " milliseconds");
        print("Path Distance: " + a);
    }

    private static void dfs(GraphGenerator<String> directedGraph, List<String> listOfStrings) {
        Map<String, Map<String, Integer>> graph = directedGraph.getGraph();
        List<String> nodes = listOfStrings;
        Set<String> visited = new HashSet<>();
        for (String node : nodes) {
            if (!visited.contains(node)) {
                dfsHelper(graph, node, visited);
            }
        }

    }

    private static void dfsHelper(Map<String, Map<String, Integer>> graph, String node, Set<String> visited) {
        visited.add(node);
        System.out.println("Visiting node: " + node);
        Map<String, Integer> neighbors = graph.get(node);
        if (neighbors != null) {
            for (String neighbor : neighbors.keySet()) {
                if (!visited.contains(neighbor)) {
                    dfsHelper(graph, neighbor, visited);
                }
            }
        }
    }

    private static void bfs(Map<String, Map<String, Integer>> graph, String startNode, List<String> listOfStrings) {
        Set<String> visited = new HashSet<>();
        Queue<String> toVisit = new LinkedList<>();
        toVisit.add(startNode);
        visited.add(startNode);
        String node = startNode;
        System.out.println("visited " + node);
        while (!toVisit.isEmpty()) {
            node = toVisit.remove();
            Map<String, Integer> neighbors = graph.get(node);

            for (String neighbor : neighbors.keySet()) {
                if (!visited.contains(neighbor)) {
                    toVisit.add(neighbor);
                    System.out.println("visited " + neighbor);
                    visited.add(neighbor);
                }
            }
        }
    }

    private static void testAStar(int[] start, int[] end, String heuristic,
            int edgeWeight) {

        AStar<String> aStar = new AStar<>(arr2D, weights);
        String startNode = arr2D.get(start[0]).get(start[1]);
        // String end = arr2D.get(arr2D.size() - 1).get(arr2D.size() - 1);

        String endNode = arr2D.get(end[0]).get(end[1]);
        long startTime = System.nanoTime();
        // reconstruct path based on the arrayList that is returned from this function
        // call
        // compare it with the path that would be returned by dijkstra's algorithm
        Integer pathDistance = aStar.runAStar(startNode, endNode, heuristic);
        long endTime = System.nanoTime();
        long duration = endTime - startTime; // in nanoseconds
        print("A* algorithm: ");
        System.out.println("Duration: " + duration / 1_000_000 + " milliseconds");
        print("Path Distance: " + pathDistance);
        // print("path found from " + start + " to: " + end);
        return;
    }

    private static void print(Object input) {
        System.out.println(input);
    }
}
